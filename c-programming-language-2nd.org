#+title: C Programming Language
#+property: header-args c :tangle no :mkdirp yes

#+begin_src emacs-lisp :results none
  (setq org-src-window-setup 'current-window)
#+end_src

* Utils

#+name: getline.c
#+begin_src c :results none :tangle code/utils/getline.c
  #include <stdio.h>

  int getline(char s[], int lim) {
    int c, i;
    i = 0;
    while (--lim > 0 && (c = getchar()) != EOF && c != '\n') {
      s[i++] = c;
    }
    if (c == '\n') {
      s[i++] = c;  
    }
    s[i] = '\0';
    return i;
  }

#+end_src

* Chapter 4. Functions and Program Structure

** Basics of Functions

#+begin_src c :results none :tangle code/4.1/grep.c
  #include <stdio.h>
  #define MAXLINE 1000


  int strindex(char source[], char searchfor[]);
  int getline(char line[], int max);

  char pattern[] = "ould";

  int main() {
    char line[MAXLINE];
    int found = 0;
    while (getline(line, MAXLINE) > 0) {
      if (strindex(line, pattern) >= 0) {
        printf("%s", line);
        found++;
      }
    }
    return found;
  }

  int strindex(char s[], char t[]) {
    int i, j , k;
    for (i = 0; s[i] != '\0'; i++) {
      for (j = i, k = 0; t[k] != '\0' && s[j] == t[k]; j++, k++) {
        
      }
      if (k > 0 && t[k] == '\0') {
        return i;
      }
    }
    return -1;
  }

#+end_src

#+begin_src shell :results none :tangle code/4.1/compile.ps1
  gcc .\grep.c ..\utils\getline.c
  Get-Content .\text.txt | .\a.exe
#+end_src

** Functions Returning Non-integers

#+begin_src c :results none :tangle code/4.2/atof.c
  #include <ctype.h>


  double atof(char s[]) {
    double val, power;
    int i, sign;
    for (i = 0; isspace(s[i]); i++) {
      /* skip white space */
    }
    sign = (s[i] == '-') ? -1 : 1;
    if (s[i] == '+' || s[i] == '-') {
      i++;
    }
    for (val = 0.0; isdigit(s[i]); i++) {
      val = 10.0 * val + (s[i] - '0');
    }
    if (s[i] == '.') {
      i++;
    }
    for (power = 1.0; isdigit(s[i]); i++) {
      val = 10.0 * val + (s[i] - '0');
      power *= 10.0;
    }
    return sign * val / power;
  }
#+end_src

#+begin_src c :results none :tangle code/4.2/main.c
  #include <stdio.h>

  #define MAXLINE 100

  int main() {
    double sum, atof(char[]);
    char line[MAXLINE];
    int getline(char line[], int max);

    sum = 0;
    while (getline(line, MAXLINE) > 0) {
      printf("\t%g\n", sum += atof(line));
    }
    return 0;
  }
#+end_src

#+begin_src shell :results none :tangle code/4.2/compile.ps1
  gcc .\main.c .\atof.c ..\utils\getline.c
#+end_src

** External Variables

#+begin_src c :results none :tangle code/4.3/calc.h
  #define NUMBER '0'              /* signal that a number was found */
  void push(double);
  double pop(void);
  int getop(char []);
  int getch(void);
  void ungetch(int);
#+end_src

#+begin_src c :results none :tangle code/4.3/main.c
  #include <stdio.h>
  #include <stdlib.h>             /* for atof() */
  #include "calc.h"

  #define MAXOP 100               /* max size of operand or operator */

  /* reverse Polish calculator */
  int main() {
    int type;
    double op2;
    char s[MAXOP];

    while ((type = getop(s)) != EOF) {
      switch(type) {
      case NUMBER:
        push(atof(s));
        break;
      case '+':
        push(pop() + pop());
        break;
      case '*':
        push(pop() * pop());
        break;
      case '-':
        op2 = pop();
        push(pop() - op2);
        break;
      case '/':
        op2 = pop();
        if (op2 != 0.0)
          push(pop() / op2);
        else
          printf("error: zero divisor\n");
        break;
      case '\n':
        printf("\t%.8g\n", pop());
        break;
      default:
        printf("error: unknown command %s\n", s);
        break;
      }
    }
    return 0;
  }
#+end_src

#+begin_src c :results none :tangle code/4.3/getop.c
  #include <stdio.h>
  #include <ctype.h>
  #include "calc.h"

  /* getop: get next operator or numberic operand */
  int getop(char s[]) {
    int i, c;
    while((s[0] = c = getch()) == ' ' || c == '\t') {
      /* skip */
    }
    s[1] = '\0';
    if (!isdigit(c) && c != '.')
      return c;                   /* not a number */
    i = 0;
    if (isdigit(c))
      while (isdigit(s[++i] = c = getch())) {
        /* collect integer part */
      }
    if (c == '.')
      while (isdigit(s[++i] = c = getch())) {
        /* collect fraction part */
      }
    s[i] = '\0';
    if (c != EOF)
      ungetch(c);
    return NUMBER;
  }
#+end_src

#+begin_src c :results none :tangle code/4.3/getch.c
  #include <stdio.h>
  #define BUFSIZE 100

  char buf[BUFSIZE];
  int bufp = 0;

  int getch(void) {
    return (bufp > 0) ? buf[--bufp] : getchar();
  }

  void ungetch(int c) {
    if (bufp >= BUFSIZE)
      printf("ungetch: too many characters\n");
    else
      buf[bufp++] = c;
  }
#+end_src

#+begin_src c :results none :tangle code/4.3/stack.c
  #include <stdio.h>
  #include "calc.h"

  #define MAXVAL 100

  int sp = 0;
  double val[MAXVAL];

  /* push: push f onto value stack */
  void push(double f) {
    if (sp < MAXVAL)
      val[sp++] = f;
    else
      printf("error: stack full, can't push %g\n", f);
  }

  /* pop: pop and return top value from stack */
  double pop(void) {
    if (sp > 0)
      return val[--sp];
    else {
      printf("error: stack empty\n");
      return 0.0;
    }
  }
#+end_src

#+name: compile from powershell
#+begin_src shell :results none :tangle code/4.3/compile.ps1
  gcc -g .\main.c .\getop.c .\getch.c .\stack.c
#+end_src

#+name: compile from shell
#+begin_src shell :results none :tangle code/4.3/compile.sh
  #!/bin/bash
  gcc -g main.c getop.c getch.c stack.c
#+end_src

After execute program, input and output will be like below.
#+begin_example
  IN: 1 1 +
  OUT: 2
  IN: 1 1 + 2 2 + *
  (1 + 1) * (2 + 2) in infix notation(?)
  OUT: 8
#+end_example

# Local Variables:
# org-confirm-babel-evaluate: nil
# End:
